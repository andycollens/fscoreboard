<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Анимированная треугольная мозаика</title>
    <style>
        /* Убираем отступы и скрываем прокрутку */
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            overflow: hidden;
            background-color: #0a0a0a; /* Фоновый цвет страницы */
        }

        /* Контейнер SVG будет занимать весь экран и находиться на заднем плане */
        #background-svg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        /* Ключевой стиль для анимации: плавный переход цвета для каждого треугольника */
        .triangle {
            transition: fill 1s ease-in-out; /* Плавный переход цвета (fill) за 1 секунду */
        }

        /* Стили для контейнера логотипа */
        #logo-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%); /* Центрирование элемента */
            z-index: 1; /* Размещаем поверх SVG */
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%; /* Занимает всю ширину для центрирования содержимого */
            height: 100%; /* Занимает всю высоту для центрирования содержимого */
            pointer-events: none; /* Позволяет кликам проходить сквозь контейнер к элементам ниже */
        }

        /* Стили для самого изображения логотипа */
        #logo {
            max-width: 80%; /* Максимальная ширина, чтобы не выходить за границы экрана */
            max-height: 80%; /* Максимальная высота, чтобы не выходить за границы экрана */
            width: auto; /* Сохраняем соотношение сторон */
            height: auto; /* Сохраняем соотношение сторон */
            opacity: 0.9; /* Небольшая прозрачность, чтобы фон просвечивал */
            filter: drop-shadow(0 0 10px rgba(0,0,0,0.5)); /* Небольшая тень для выделения */
        }
    </style>
</head>
<body>

    <!-- SVG-элемент, который будет заполнен треугольниками с помощью JavaScript -->
    <svg id="background-svg"></svg>

    <!-- Контейнер для логотипа, размещенный поверх SVG -->
    <div id="logo-container">
        <img id="logo" src="/public/img/ISKRA-hor_logo.png" alt="ISKRA Logo">
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const svg = document.getElementById('background-svg');
            const namespace = "http://www.w3.org/2000/svg";

            // Палитра темных цветов, как в примере
            const colors = ['#080808', '#101010', '#181818', '#202020', '#282828'];

            // --- Параметры сетки ---
            const triangleSize = 20; // Размер стороны равностороннего треугольника (уменьшен)
            const triangleHeight = triangleSize * Math.sqrt(3) / 2; // Высота равностороннего треугольника

            let screenWidth = window.innerWidth;
            let screenHeight = window.innerHeight;
            let resizeTimeout; // Для задержки вызова createGrid на resize

            function createGrid() {
                // Получаем актуальные размеры окна
                screenWidth = window.innerWidth;
                screenHeight = window.innerHeight;

                // Устанавливаем атрибуты width и height для SVG-элемента
                // Это может помочь в некоторых средах, таких как Streamlabs Browser Source,
                // где CSS-свойства могут вести себя иначе при масштабировании.
                svg.setAttribute('width', screenWidth);
                svg.setAttribute('height', screenHeight);
                // Устанавливаем viewBox, чтобы SVG-содержимое масштабировалось
                // в соответствии с размером элемента SVG
                svg.setAttribute('viewBox', `0 0 ${screenWidth} ${screenHeight}`);

                // Очищаем SVG перед перерисовкой
                while (svg.firstChild) {
                    svg.removeChild(svg.firstChild);
                }
                
                // Рассчитываем количество строк и столбцов для заполнения экрана
                const numCols = Math.ceil(screenWidth / triangleSize) + 1;
                const numRows = Math.ceil(screenHeight / triangleHeight) + 1;

                for (let row = 0; row < numRows; row++) {
                    for (let col = 0; col < numCols; col++) {
                        // Определяем начальную позицию для пары треугольников
                        const x = col * triangleSize;
                        const y = row * triangleHeight;

                        // Смещаем каждую вторую строку для создания плотной сетки
                        const offsetX = (row % 2 === 0) ? 0 : triangleSize / 2;

                        // Выбираем случайные цвета для начальной мозаики
                        const randomColor1 = colors[Math.floor(Math.random() * colors.length)];
                        const randomColor2 = colors[Math.floor(Math.random() * colors.length)];

                        // Создаем два треугольника (один смотрит вверх, другой вниз),
                        // которые вместе образуют ромб в сетке
                        createTriangle(x - offsetX, y, 'down', randomColor1);
                        createTriangle(x - offsetX + (triangleSize / 2), y, 'up', randomColor2);
                    }
                }
            }

            function createTriangle(x, y, direction, color) {
                const polygon = document.createElementNS(namespace, 'polygon');
                polygon.classList.add('triangle');

                let points;
                if (direction === 'up') {
                    points = `${x},${y + triangleHeight} ${x + triangleSize / 2},${y} ${x + triangleSize},${y + triangleHeight}`;
                } else { // 'down'
                    points = `${x},${y} ${x + triangleSize},${y} ${x + triangleSize / 2},${y + triangleHeight}`;
                }

                polygon.setAttribute('points', points);
                polygon.setAttribute('fill', color);
                svg.appendChild(polygon);
            }

            // --- Анимация ---
            function animateMosaic() {
                const allTriangles = document.querySelectorAll('.triangle');
                if (allTriangles.length === 0) return;

                // Выбираем случайный треугольник для изменения цвета
                const randomIndex = Math.floor(Math.random() * allTriangles.length);
                const triangleToAnimate = allTriangles[randomIndex];

                // Выбираем новый случайный цвет, который не совпадает с текущим
                const currentColor = triangleToAnimate.getAttribute('fill');
                let newColor;
                do {
                    newColor = colors[Math.floor(Math.random() * colors.length)];
                } while (newColor === currentColor);

                // Присваиваем новый цвет. CSS transition сделает анимацию плавной
                triangleToAnimate.setAttribute('fill', newColor);
            }

            // Запускаем создание сетки и анимацию
            createGrid();

            // Запускаем анимацию с небольшим интервалом для создания эффекта "мерцания"
            setInterval(animateMosaic, 100);

            // Перерисовываем сетку при изменении размера окна с небольшой задержкой (debounce)
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(createGrid, 250); // Задержка 250 мс
            });
        });
    </script>

</body>
</html>